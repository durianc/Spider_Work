{'content': '思路很简单：从每一个火把或萤石为中心枚举每一个有亮光的地方，标记后统计没有标记的地方的个数即可。。\n\n \n但是。。\n\n直接暴力写的话。。\n\n少则六七十行，\n\n多则。。（不忍直视的长。。）\n\n \n所以，为了代码简洁，\n\n我就为大家带来高强度for的自带注释的压缩版本：\n\n（当当当当）\n\n \n\n\n\n\n```cpp\n#include <bits/stdc++.h> \nusing namespace std;\nint n, m, k, a, b, ans;\nint s[5005][5005];\nbool pd(int x, int y) { //判断是否越界 \n    if(x < 1 || y < 1 || x > n || y > n) return 0;\n    return 1;\n}\nint main() {\n    scanf("%d%d%d", &n, &m, &k); //读入 \n    for(int i = 1; i <= m + k; i++) { //由于计算火把和萤石的步骤很像，所以合并了 \n        scanf("%d%d", &a, &b); //读入坐标 \n        for(int x = -2; x <= 2; x++)\n            for(int y = -2; y <= 2; y++) //枚举5*5的方阵(通过计算距离) \n                if((i > m || abs(x) + abs(y) <= 2) && pd(x + a, b + y))\n                //如果是萤石(i > m)或者x与y的坐标差的和不超过2(想一想为什么)并且\n                //没有越界就标记 \n                    s[x + a][b + y]++;\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            ans += s[i][j] == 0; //枚举每一个方格，看看是不是==0(即没有亮光) \n    printf("%d\\n", ans); //输出结果 \n    return 0;\n}\n//希望我能帮到各位。。 \n//希望大慈大悲的管理员给过。。\n```', 'type': '题解', 'status': 2, 'postTime': 1509537465, 'author': {'uid': 20782, 'name': 'CYJian', 'slogan': '今日はこっちの地方はどしゃぶりの晴天でした，昨日もずっと暇で一日満喫してました', 'badge': '舟学家', 'isAdmin': True, 'isBanned': False, 'color': 'Purple', 'ccfLevel': 10, 'background': 'https://cdn.luogu.com.cn/upload/image_hosting/yf14wex9.png'}, 'thumbUp': 427, 'commentCount': 107, 'currentUserVoteType': 0, 'contentDescription': '思路很简单：从每一个火把或萤石为中心枚举每一个有亮光的地方，标记后统计没有标记的地方的个数即可。。\n但是。。\n直接暴力写的话。。\n少则六七十行，\n多则。。（不忍直视的长。。）\n所以，为了代码简洁...', 'id': 9309, 'identifier': 'solution-p1789', 'title': '题解 P1789 【【Mc生存】插火把】'}